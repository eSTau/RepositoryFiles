////////////////////////////////////////////////////////////////////////////////
// Подсистема "Работы с файлами внешнего хранилища данных".
//
////////////////////////////////////////////////////////////////////////////////

#Область ПРОГРАММНЫЙ_ИНТЕРФЕЙС

Функция ЕстьДанные(Ссылка, Отказ = Ложь) Экспорт
	
	Возврат ФайлСодержитДвоичныеДанные(Ссылка);
	
КонецФункции // ЕстьДанные()

Функция ВернутьВерсиюДанных(Ссылка, Отказ = Ложь) Экспорт
	
	//--<Хорошев Андрей 23.06.2016 18:16:10 РИ-004978
	ИмяТаблицы=table_name(Ссылка);
	Если МодульРаботыСФайламиХранилищаДанныхПовтИсп.ХранимТаблицуНаMySQL(ИмяТаблицы) Тогда
		Если не ПроверитьПодключениеКMySQL() Тогда
			Возврат Неопределено;
		КонецЕсли;
		Возврат Ссылка["Ссылка"+ИмяТаблицы].Version;
	КонецЕсли;
	//-->Хорошев Андрей 23.06.2016 18:16:10 РИ-004978
	
	Возврат VersionData(ИмяТаблицы, id_pointer(Ссылка.УникальныйИдентификатор()), Отказ)
	
КонецФункции // ВернутьВерсиюДанных()

// НУЖНО НАСТРОИТЬ ЭТОТ ФУНКЦИОНАЛ
Функция ПроверкаИспользованияХранилищаВРабочейБазе(Ссылка=Неопределено)
	
	Возврат Истина;
	
	Если Ссылка = Неопределено или МодульРаботыСФайламиХранилищаДанныхПовтИсп.ХранимТаблицуНаMySQL(table_name(Ссылка)) Тогда
		ЭтоРабочееХранилище=МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочееХранилищеДанныхMySQL();
	Иначе
		ЭтоРабочееХранилище=МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочееХранилищеДанных();
	КонецЕсли; 
	
	Если не МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочаяБазаДанных() = ЭтоРабочееХранилище Тогда 
		// ВНИМАНИЕ! ПРОВЕРКА НА ИЗМЕНЕНИЕ В РАБОЧЕМ ХРАНИЛИЩЕ
		СтрокаСообщения = "Попытка работы из "
			+ ?(МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочаяБазаДанных(), "рабочей", "тестовой") + " бызы с "
			+ ?(ЭтоРабочееХранилище, "рабочим", "тестовым") + " хранилищем";
		
		ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, , "Внешнее хранилище данных");
		ЗаписьЖурналаРегистрации("Внешнее хранилище данных.Обновление инфо данных", УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.ФайлыХранилищаДанных, Ссылка, СтрокаСообщения);
		
		Возврат Ложь;
	
	КонецЕсли; 
	
	Возврат Истина;
	
КонецФункции

Функция ОбновитьИнфоДанных(Ссылка, Поле, НовоеЗначение, Отказ = Ложь) Экспорт
	
	Если Поле = "ПометкаУдаления" Тогда 
		ИмяПоля = "Marked";
	ИначеЕсли Поле = "ИмяФайла" Тогда
		ИмяПоля = "Description";
	Иначе
		ОбщегоНазначения.СообщитьОбОшибке("Недоступное поле для обновления!", Отказ, "Обновление инфо данных"); Возврат не Отказ;
	КонецЕсли;
	
	Если не ПроверкаИспользованияХранилищаВРабочейБазе(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Метаданные.ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(Ссылка))) Тогда
		Отказ=не ПроверитьПодключениеКMySQL();
		Если не Отказ и не Ссылка.Пустая() Тогда
			ТекДанные=Ссылка.ПолучитьОбъект();
			Если ТекДанные=Неопределено Тогда
				СтрокаСообщения = "Ошибка при установки нового значения поля "+Поле+" таблицы "+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Имя+" в базе mySQL:
				|Элемент не найден в базе данных!";
				ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, Отказ, "Внешнее хранилище данных");
				ЗаписьЖурналаРегистрации("Внешнее хранилище данных.Удаление данных", УровеньЖурналаРегистрации.Ошибка, Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)), Ссылка, СтрокаСообщения);
				Отказ=Истина;
				Возврат Ложь;
			КонецЕсли; 
			ТекДанные[ИмяПоля]=НовоеЗначение;
			Попытка
				ТекДанные.Записать();
			Исключение
				СтрокаСообщения = "Ошибка при установки нового значения поля "+Поле+" таблицы "+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Имя+" в базе mySQL:
				|"+ОписаниеОшибки();
				ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, Отказ, "Внешнее хранилище данных");
				ЗаписьЖурналаРегистрации("Внешнее хранилище данных.Удаление данных", УровеньЖурналаРегистрации.Ошибка, Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)), Ссылка, СтрокаСообщения);
			КонецПопытки;
		КонецЕсли;
		Возврат не Отказ;
	КонецЕсли;
	
	//--<Хорошев Андрей 23.06.2016 13:00:16 РИ-004978
	ИмяТаблицы=table_name(Ссылка);
	Если МодульРаботыСФайламиХранилищаДанныхПовтИсп.ХранимТаблицуНаMySQL(ИмяТаблицы) Тогда
		Отказ=не ПроверитьПодключениеКMySQL();
		Если не Отказ и не Ссылка["Ссылка"+ИмяТаблицы].Пустая() Тогда
			ТекДанные=Ссылка["Ссылка"+ИмяТаблицы].ПолучитьОбъект();
			ТекДанные[ИмяПоля]=НовоеЗначение;
			Попытка
				ТекДанные.Записать();
			Исключение
				СтрокаСообщения = "Ошибка при установки нового значения поля "+Поле+" таблицы "+ИмяТаблицы+" в базе mySQL:
				|"+ОписаниеОшибки();
				ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, Отказ, "Внешнее хранилище данных");
				ЗаписьЖурналаРегистрации("Внешнее хранилище данных.Удаление данных", УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.ФайлыХранилищаДанных, Ссылка, СтрокаСообщения);
			КонецПопытки;
		КонецЕсли;
		Возврат не Отказ;
	КонецЕсли;
	//-->Хорошев Андрей 23.06.2016 13:00:16 РИ-004978
	
	Если ТипЗнч(НовоеЗначение) = Тип("Булево") Тогда 
		ПредставлениеЗначния = "0x0" + ЧИСЛО(НовоеЗначение);
	Иначе
		ОбщегоНазначения.СообщитьОбОшибке("Недоступное значение для обновления!", Отказ, "Обновление инфо данных"); Возврат не Отказ;
	КонецЕсли;
	
	Возврат UpdateInfo(ИмяТаблицы, id_pointer(Ссылка.УникальныйИдентификатор()), ИмяПоля, ПредставлениеЗначния, Отказ);
	
КонецФункции // ОбновитьИнфоДанных()

Функция УдалитьДанные(Ссылка, Отказ = Ложь) Экспорт
	
	Если не ПроверкаИспользованияХранилищаВРабочейБазе(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	//--<Хорошев Андрей 23.06.2016 10:53:38 РИ-004978
	Если Метаданные.ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(Ссылка))) Тогда
		Отказ=не ПроверитьПодключениеКMySQL();
		Если не Отказ Тогда 
			ТекДанные=Ссылка.ПолучитьОбъект();
			Попытка
				ТекДанные.Удалить();
			Исключение
				СтрокаСообщения = "Ошибка при удалении данных из базы mySQL:
				|"+ОписаниеОшибки();
				ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, Отказ, "Внешнее хранилище данных");
				ЗаписьЖурналаРегистрации("Внешнее хранилище данных.Удаление данных", УровеньЖурналаРегистрации.Ошибка, Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)), Ссылка, СтрокаСообщения);
			КонецПопытки;
		КонецЕсли;
		Возврат не Отказ;
	КонецЕсли;
	
	ИмяТаблицы=table_name(Ссылка);
	Если МодульРаботыСФайламиХранилищаДанныхПовтИсп.ХранимТаблицуНаMySQL(ИмяТаблицы) Тогда
		Отказ=не ПроверитьПодключениеКMySQL();
		Если не Отказ И не Ссылка["Ссылка"+ИмяТаблицы].Пустая() Тогда
			ТекДанные=Ссылка["Ссылка"+ИмяТаблицы].ПолучитьОбъект();
			ТекДанные.ДополнительныеСвойства.Вставить("Владелец", Ссылка);
			Попытка
				ТекДанные.Удалить();
			Исключение
				СтрокаСообщения = "Ошибка при удалении данных из базы mySQL:
				|"+ОписаниеОшибки();
				ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, Отказ, "Внешнее хранилище данных");
				ЗаписьЖурналаРегистрации("Внешнее хранилище данных.Удаление данных", УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.ФайлыХранилищаДанных, Ссылка, СтрокаСообщения);
			КонецПопытки;
		КонецЕсли;
		Возврат не Отказ;
	КонецЕсли; 
	//-->Хорошев Андрей 23.06.2016 10:53:43 РИ-004978 
	
	Возврат DeleteData(ИмяТаблицы, id_pointer(Ссылка.УникальныйИдентификатор()), Отказ);

КонецФункции // УдалитьДанные()

Функция ПоместитьДанные(Ссылка, Знач Адрес, Отказ) Экспорт
	
	Перем Данные, Версия, ИмяФайла;
	
	СтруктураДанных = ПолучитьИзВременногоХранилища(Адрес);
	СтруктураДанных.Свойство("Данные", Данные); 
	СтруктураДанных.Свойство("Версия", Версия); 
	СтруктураДанных.Свойство("ИмяФайла", ИмяФайла); 
	УдалитьИзВременногоХранилища(Адрес);
	
	Если СтрДлина(ИмяФайла) > 128 Тогда 
		ИмяФайла = "~"+Прав(ИмяФайла, 127);
	КонецЕсли;
	
	//--<Хорошев Андрей 22.06.2016 13:38:48 РИ-004978
	Если не ПроверкаИспользованияХранилищаВРабочейБазе(Ссылка) Тогда
		Отказ=Истина;
		Возврат Неопределено;
	КонецЕсли;
	
	Если Метаданные.ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(Ссылка))) Тогда
		Если не ПроверитьПодключениеКMySQL() Тогда
			Отказ=Истина;
			Возврат Неопределено;
		КонецЕсли;
		СтрДанных=Base64Строка(Данные);
		Если Ссылка.Data=СтрДанных и Ссылка.Description=ИмяФайла Тогда
			//Ничего не меняем
			Возврат Ссылка;
		КонецЕсли; 
		ТекДанные=Ссылка.ПолучитьОбъект();
		ТекДанные.Data=СтрДанных;
		ТекДанные.Description=ИмяФайла;
		ТекДанные.Записать();
		Возврат ТекДанные.Ссылка;
		
	КонецЕсли;
	
	ИмяТаблицы=table_name(Ссылка);
	Если МодульРаботыСФайламиХранилищаДанныхПовтИсп.ХранимТаблицуНаMySQL(ИмяТаблицы) Тогда
		Если не ПроверитьПодключениеКMySQL() Тогда
			Отказ=Истина;
			Возврат Неопределено;
		КонецЕсли; 
		Если Ссылка["Ссылка"+ИмяТаблицы].Пустая() или Найти(Строка(Ссылка["Ссылка"+ИмяТаблицы]),"<Объект не найден>")=1 Тогда
			ТекДанные=ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы[ИмяТаблицы].СоздатьОбъект();
		Иначе
			ТекДанные=Ссылка["Ссылка"+ИмяТаблицы].ПолучитьОбъект();
		КонецЕсли;
		
		ТекДанные.Data=Base64Строка(Данные);
		ТекДанные.Description=ИмяФайла;
		ТекДанные.Записать();
		Возврат ТекДанные.Ссылка;
	Иначе
		exec_put(ИмяТаблицы, id_pointer(Ссылка.УникальныйИдентификатор()), Данные, СтрЗаменить(ИмяФайла, "'",""), Отказ, Версия);
	КонецЕсли;
	//-->Хорошев Андрей 22.06.2016 13:38:51 РИ-004978 
	
КонецФункции // ПоместитьДанные()

Процедура ПолучитьДанные(Ссылка, Адрес = Неопределено, Отказ, Версия = Неопределено) Экспорт
	
	Перем Данные, ИмяФайла;
	//--<Хорошев Андрей 23.06.2016 9:28:09 РИ-004978
	ИмяТаблицы=table_name(Ссылка);
	Если МодульРаботыСФайламиХранилищаДанныхПовтИсп.ХранимТаблицуНаMySQL(ИмяТаблицы) Тогда
		Отказ=не ПроверитьПодключениеКMySQL();
		Если не отказ Тогда
			//Получаем данные через запрос к внешней таблице
			Запрос=Новый Запрос("ВЫБРАТЬ
			                    |	ВнТаблица.Version КАК Версия,
			                    |	ВнТаблица.Представление КАК ИмяФайла,
			                    |	ВнТаблица.Data КАК Данные
			                    |ИЗ
			                    |	ВнешнийИсточникДанных.ФайловоеХранилище.Таблица."+ИмяТаблицы+" КАК ВнТаблица
			                    |ГДЕ
			                    |	ВнТаблица.Ссылка = &Ссылка");
			Запрос.УстановитьПараметр("Ссылка", Ссылка["Ссылка"+ИмяТаблицы]);
			Попытка
				Выборка=Запрос.Выполнить().Выбрать();
			Исключение
				Сообщить("Ошибка при получении данных из хранилища:
				|"+ОписаниеОшибки());
				Отказ=Истина;
			КонецПопытки;
			Если не Отказ и Выборка.Следующий() Тогда
				Данные=Base64Значение(Выборка.Данные);
				Версия=Выборка.Версия;
				ИмяФайла=Выборка.ИмяФайла;
			Иначе
				//Не смогли найти файлик
				Отказ=Истина;
			КонецЕсли; 
		КонецЕсли;
	Иначе
	//-->Хорошев Андрей 23.06.2016 9:28:18 РИ-004978
		
		exec_get(ИмяТаблицы, id_pointer(Ссылка.УникальныйИдентификатор()), Данные, ИмяФайла, Отказ, Версия);
	КонецЕсли;
	
	Если Отказ Тогда
		Данные = Справочники.ФайлыХранилищаДанных.ПолучитьМакет("КартинкаПоУмолчанию");
	КонецЕсли;
	
	Если Адрес=Неопределено или не ЭтоАдресВременногоХранилища(Адрес) Тогда
		Адрес = ПоместитьВоВременноеХранилище(Новый Структура("Данные,Версия,ИмяФайла", Данные, Версия, ИмяФайла));
	Иначе
		ПоместитьВоВременноеХранилище(Новый Структура("Данные,Версия,ИмяФайла", Данные, Версия, ИмяФайла), Адрес);
	КонецЕсли; 
		
КонецПроцедуры // ПолучитьДанные()

Функция ПоместитьПроизвольныеДанные(Знач Адрес, ИмяТаблицы, ВнешняяСсылка=Неопределено, Отказ) Экспорт
	
	Перем Данные, Версия, ИмяФайла;
	
	СтруктураДанных = ПолучитьИзВременногоХранилища(Адрес);
	СтруктураДанных.Свойство("Данные", Данные); 
	СтруктураДанных.Свойство("Версия", Версия); 
	СтруктураДанных.Свойство("ИмяФайла", ИмяФайла); 
	УдалитьИзВременногоХранилища(Адрес);
	
	Если СтрДлина(ИмяФайла) > 128 Тогда 
		ИмяФайла = "~"+Прав(ИмяФайла, 127);
	КонецЕсли;
	
	Если не ПроверкаИспользованияХранилищаВРабочейБазе() Тогда
		Отказ=Истина;
		Возврат Неопределено;
	КонецЕсли;
	
	Если не ПроверитьПодключениеКMySQL() Тогда
		Отказ=Истина;
		Возврат Неопределено;
	КонецЕсли; 
	Если ВнешняяСсылка=Неопределено или ВнешняяСсылка=ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы[ИмяТаблицы].ПустаяСсылка() или Найти(Строка(ВнешняяСсылка),"<Объект не найден>")=1 Тогда
		ТекДанные=ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы[ИмяТаблицы].СоздатьОбъект();
	Иначе
		ТекДанные=ВнешняяСсылка.ПолучитьОбъект();
	КонецЕсли;
	ТекДанные.Data=Base64Строка(Данные);
	ТекДанные.Description=ИмяФайла;
	ТекДанные.Записать();
	Возврат ТекДанные.Ссылка;
	
КонецФункции
 
Процедура ПолучитьПроизвольныеДанные(Адрес = Неопределено, ИмяТаблицы, ВнешняяСсылка, Отказ, Версия = Неопределено) Экспорт
	
	Перем Данные, ИмяФайла;
	
	Отказ=не ПроверитьПодключениеКMySQL();
	Если не отказ Тогда
		//Получаем данные через запрос к внешней таблице
		Запрос=Новый Запрос("ВЫБРАТЬ
		                    |	ВнТаблица.Version КАК Версия,
		                    |	ВнТаблица.Представление КАК ИмяФайла,
		                    |	ВнТаблица.Data КАК Данные
		                    |ИЗ
		                    |	ВнешнийИсточникДанных.ФайловоеХранилище.Таблица."+ИмяТаблицы+" КАК ВнТаблица
		                    |ГДЕ
		                    |	ВнТаблица.Ссылка = &Ссылка");
		Запрос.УстановитьПараметр("Ссылка", ВнешняяСсылка);
		Выборка=Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Данные=Base64Значение(Выборка.Данные);
			Версия=Выборка.Версия;
			ИмяФайла=Выборка.ИмяФайла;
		Иначе
			//Не смогли найти файлик
			Отказ=Истина;
		КонецЕсли; 
	КонецЕсли;
	
	Если Отказ Тогда
		Данные = Неопределено;
	КонецЕсли;
	
	Если Адрес=Неопределено или не ЭтоАдресВременногоХранилища(Адрес) Тогда
		Адрес = ПоместитьВоВременноеХранилище(Новый Структура("Данные,Версия,ИмяФайла", Данные, Версия, ИмяФайла));
	Иначе
		ПоместитьВоВременноеХранилище(Новый Структура("Данные,Версия,ИмяФайла", Данные, Версия, ИмяФайла), Адрес);
	КонецЕсли; 
		
КонецПроцедуры // ПолучитьДанные()

// Возвращает ссылку на файл привязанный к объекту системы
//
// Параметры:
//  Тип		 - ПеречисленияСсылка.ТипыФайловХранилищаДанных - Значение перечисления которо соответствует
//		имени таблицы внешнего хранилище в которой хранятся файлы связанные с объетом данного типа.
//  Объект	 - СсылкаСпр, СсылкаДок - Ссылка на объект который связан с файлом харимом во внешнем хранилище.
//		(Список допистимых классов см. спр.ФайлыХранилищаДанных.Тип).
// 
// Возвращаемое значение:
//  СправочникиСсылка.ФайлыХранилищаДанных - ссылка на элемент справочника, который является связующим звеном
//		между Объектом и файлом хранимым во внешнем хранилище.
//
Функция ВернутьСсылкуНаФайл(Тип, Объект) Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ
	|	ФайлыХранилищаДанных.Ссылка
	|ИЗ
	|	Справочник.ФайлыХранилищаДанных КАК ФайлыХранилищаДанных
	|ГДЕ
	|	ФайлыХранилищаДанных.Тип = &Тип
	|	И ФайлыХранилищаДанных.Объект = &Объект";
	
	Запрос.УстановитьПараметр("Тип"		, Тип);
	Запрос.УстановитьПараметр("Объект"	, Объект);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда 
		Результат = Справочники.ФайлыХранилищаДанных.ПустаяСсылка();
	Иначе
		Результат = РезультатЗапроса.Выгрузить()[0].Ссылка;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ВернутьСсылкуНаФайл()

Функция ВернутьМассивСсылокНаФайлы(Тип, Объект) Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ
	|	ФайлыХранилищаДанных.Ссылка
	|ИЗ
	|	Справочник.ФайлыХранилищаДанных КАК ФайлыХранилищаДанных
	|ГДЕ
	|	ФайлыХранилищаДанных.Тип = &Тип
	|	И ФайлыХранилищаДанных.Объект = &Объект
	|	И НЕ ФайлыХранилищаДанных.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("Тип"		, Тип);
	Запрос.УстановитьПараметр("Объект"	, Объект);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Возврат РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции // ВернутьМассивСсылокНаФайлы()

// Проверяет и возвращает признак того использует ли система внешнее хранилище
//
// Параметры:
//  Дата - Дата - Не обязательное. Дата на котору необходимо проверить использование хранилища.
// 
// Возвращаемое значение:
//  Булево - Истина, если система использует внешнее хранилище, Ложь иначе.
//
Функция ИспользованиеВнешнегоХранилища(Дата = Неопределено) Экспорт
	
	Если Дата = Неопределено Тогда 
		Дата = НачалоМесяца(ПроверкаРазницыВремени.ТекущаяДатаСервера());
	КонецЕсли;
	
	Возврат МодульСлужебнойОбработкиПовтИсп.РегистрыСведений_УчетнаяПолитика_ПолучитьПоследнее(НачалоМесяца(Дата))["ИспользоватьВнешнееХранилище"];
	
КонецФункции // ИспользованиеВнешнегоХранилища

Функция ИспользованиеВнешнегоХранилищаНаЭтапеТестирования(ИмяБлока, Дата = Неопределено) Экспорт
	
	Если Дата = Неопределено Тогда 
		Дата = НачалоМесяца(ПроверкаРазницыВремени.ТекущаяДатаСервера());
	КонецЕсли;
	
	Возврат МодульСлужебнойОбработкиПовтИсп.РегистрыСведений_УчетнаяПолитика_ПолучитьПоследнее(НачалоМесяца(Дата))["ИспользоватьВнешнееХранилище"]
		  И РегистрыСведений._служебныйФункционалНаЭтапеТестирования.ФункционалВключен("ИспользоватьВнешнееХранилище"+ИмяБлока);
	
КонецФункции // ИспользованиеВнешнегоХранилищаНаЭтапеТестирования

//▼ РИ-008846 | 20.11.18-17:52 | Юдин Константин // ☯ ДОРАБОТКА 
Процедура ПрерватьДолгиеВызовыНаСервереMySql() Экспорт
	
	АДОСоединение = Новый COMОбъект("ADODB.Connection");
	
	Если АДОСоединение.State = 0 // 0 - adStateClosed
		Тогда
		SRV = "192.168.0.65"; //адрес сервера MySQL
		DB = "files1c";//имя базы MySQL
		UID = "Yudin";//имя пользователя MySQL
		PWD = "Gfhjkm2011";//пароль пользователя MySQL        
		PORT = "3306";//порт сервера MySQL, например 3306
		cstr = "DRIVER={MySQL ODBC 5.3 Unicode Driver};
		|SERVER=" + SRV + ";UID=" + UID + ";
		|PASSWORD=" + PWD + ";DATABASE=" + DB + ";PORT=" + PORT + ";";
		Попытка
			АДОСоединение.Open(cstr);
		Исключение
			АДОСоединение = Неопределено;
			Сообщить(ОписаниеОшибки());
		КонецПопытки;
	КонецЕсли;
	
	//АДОСоединение.Execute("Kill 110");
	
	ТекстЗапроса = "SELECT * FROM information_schema.processlist WHERE TIME > 1000 AND DB = 'files1c' AND USER = 'usr1c' AND Command = 'Query'";
	
	Table = АДОСоединение.Execute(ТекстЗапроса); 
	
	Пока Table.EOF() = 0 Цикл 
		
		Сообщить(Table.Fields("ID").Value); 
		АДОСоединение.Execute("Kill " + Формат(Table.Fields("ID").Value, "ЧГ="));
		Table.MoveNext();
		
	КонецЦикла;
	
	Table.Close();
	
КонецПроцедуры // ПрерватьДолгиеВызовыНаСервереMySql()


#КонецОбласти

#Область СЛУЖЕБНЫЕ_ПРОЦЕДУРЫ_И_ФУНКЦИИ

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ СЛУЖЕБНОГО НАЗНАЧЕНИЯ

Функция ПроверитьПодключениеКMySQL() Экспорт
	
	Возврат ВнешнееХранилищеФайловПодключено();
	
	Если ВнешниеИсточникиДанных.ФайловоеХранилище.ПолучитьСостояние()=СостояниеВнешнегоИсточникаДанных.Отключен Тогда
		//Хорошев Андрей - сначала пытаемся подключиться с общими настройками
		Попытка
			ВнешниеИсточникиДанных.ФайловоеХранилище.УстановитьСоединение();
			Возврат Истина;
		Исключение
		КонецПопытки;
		Парам=ВнешниеИсточникиДанных.ФайловоеХранилище.ПолучитьОбщиеПараметрыСоединения();
		Если не Парам.ПарольУстановлен Тогда
			//Параметры не заданы, воспользуемся данными из константы
			Парам=Константы.ПараметрыПодключенияКХранилищуMySQL.Получить().Получить();
			Если ТипЗнч(Парам)<>Тип("ПараметрыСоединенияВнешнегоИсточникаДанных") Тогда
				ВызватьИсключение "Не заполнены параметры подключения к базе данных!";
			КонецЕсли; 
			Парам.АутентификацияОС=Ложь;
			Парам.СУБД="MySQL";
			//Для истории
			//Парам.ИмяПользователя="usr1c";
			//Парам.Пароль="!Q2w3e4r";
			//Парам.СтрокаСоединения="DRIVER={MySQL ODBC 5.3 Unicode Driver};UID=usr1c;SERVER={192.168.0.65};DATABASE=files1c;";
		КонецЕсли; 
		ВнешниеИсточникиДанных.ФайловоеХранилище.УстановитьПараметрыСоединенияСеанса(Парам);
		Попытка
			ВнешниеИсточникиДанных.ФайловоеХранилище.УстановитьСоединение();
		Исключение
			ТекстОшибки="Ошибка подключения к внешней базе mySQL: "+ОписаниеОшибки();
			Сообщить(ТекстОшибки, СтатусСообщения.ОченьВажное);
			//Сбрасываем пароль
			Парам.Пароль="";
			ВнешниеИсточникиДанных.ФайловоеХранилище.УстановитьОбщиеПараметрыСоединения(Парам);
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

function TestAccess()
	
	return exec_text("SELECT 1", , "result = excp")

endfunction // TestAccess()

function GetStorageConnectionString()
	
	return МодульРаботыСФайламиХранилищаДанныхПовтИсп.GetStorageConnectionString();
	
endfunction // GetStorageConnectionString()
// Удалить
function ExistData(val table, val id, excp = false)
	
	return not exec_text("SELECT IDRRef FROM "+table+" WITH (HOLDLOCK) WHERE IDRRef = 0x" + ID, , "result = Recordset.EOF and Recordset.BOF", excp);
	
endfunction // ExistData()

function VersionData(val table, val id, excp = false)
	
	return exec_text("SELECT Version FROM "+table+" WITH (HOLDLOCK) WHERE IDRRef = 0x" + ID, , "version = null; while not Recordset.EOF do version = Recordset.Fields(""Version"").Value; Recordset.MoveNext() enddo;
		|if not version = null then Stream = undefined; fullfilename_vrn = GetTempFileName(); WriteStream(Stream, fullfilename_vrn, version, excp); result = new BinaryData(fullfilename_vrn); DeleteFiles(fullfilename_vrn) endif" , excp);
	
endfunction // VersionData()

function id_pointer(uid) Экспорт
	
	id = StrReplace(uid, "-", "");
	return Upper(Mid(id,17,16)+Mid(id,13,4)+Mid(id,9,4)+Mid(id,1,8));
	
endfunction // id_pointer()

function table_name(Ссылка) Экспорт
	
	//Функция для переданного объекта возвращает его тип, для сохранения во внешней базе
	Если ТипЗнч(Ссылка)=Тип("СправочникСсылка.ВложенияЭлектронныхПисем") или ТипЗнч(Ссылка)=Тип("СправочникОбъект.ВложенияЭлектронныхПисем") Тогда
		Возврат Metadata.Enums.ТипыФайловХранилищаДанных.EnumValues[Enums.ТипыФайловХранилищаДанных.IndexOf(Перечисления.ТипыФайловХранилищаДанных.Attachments)].Name;
	ИначеЕсли ТипЗнч(Ссылка)=Тип("ПеречислениеСсылка.ТипыФайловХранилищаДанных") Тогда
		Возврат Metadata.Enums.ТипыФайловХранилищаДанных.EnumValues[Enums.ТипыФайловХранилищаДанных.IndexOf(Ссылка)].Name;
	ИначеЕсли Метаданные.ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(Ссылка))) Тогда
		Возврат Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ИмяВИсточникеДанных;
	КонецЕсли;
	
	//Проверяем, если в метаданных переданного типа есть реквизит "тип" со значением Перечисление.ТипыФайловХранилищаДанных, то возвращаем его
	МдРекв=Ссылка.Метаданные().Реквизиты.Найти("тип");
	Если МдРекв=Неопределено Тогда
		ВызватьИсключение "В функцию ""table_name"" передана ссылка на неизвестный объект "+Ссылка+" ("+ТипЗнч(Ссылка)+")";
	ИначеЕсли не МдРекв.Тип.СодержитТип(Тип("ПеречислениеСсылка.ТипыФайловХранилищаДанных")) Тогда 
		ВызватьИсключение "В функцию ""table_name"" передана ссылка на объект "+Ссылка+" ("+ТипЗнч(Ссылка)+"), который содержит реквизит ""Тип"" не соответсвующий перечислению ""ТипыФайловХранилищаДанных""";
	ИначеЕсли Ссылка.Тип.Пустая() Тогда 
		ВызватьИсключение "В функцию ""table_name"" передана ссылка на объект "+Ссылка+" ("+ТипЗнч(Ссылка)+"), с незаполненым реквизитом ""Тип""";
	КонецЕсли;
	
	return Metadata.Enums.ТипыФайловХранилищаДанных.EnumValues[Enums.ТипыФайловХранилищаДанных.IndexOf(Ссылка.Тип)].Name;

endfunction // table_name()

function ValueData(val table, val id, excp = false)
	
	return exec_text("SELECT Data FROM "+table+" WITH (HOLDLOCK) WHERE IDRRef = 0x" + ID, , "result = null; while not Recordset.EOF do result = Recordset.Fields(""Data"").Value; Recordset.MoveNext() enddo; ", excp);
	
endfunction // ValueData()

function UpdateInfo(val table, val id, val col, val value, excp = false) 
	
	return exec_text("UPDATE "+table+" WITH (HOLDLOCK) SET "+col+" = "+value+" WHERE IDRRef = 0x" + ID, , "result = not excp", excp);
	
endfunction // UpdateInfo()

function DeleteData(val table, val id, excp = false) 
	
	return exec_text("DELETE "+table+" WITH (HOLDLOCK) WHERE IDRRef = 0x" + ID, , "result = not excp", excp);
	
endfunction // DeleteData()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ СПЕЦИАЛЬНОГО НАЗНАЧЕНИЯ

procedure OpenConnection(Connection, ConnectionString = "", excp = false) 
	
	if IsBlankString(ConnectionString) then ConnectionString = GetStorageConnectionString() endif;
	
	try Connection = new COMОбъект("ADODB.Connection"); Connection.Open(ConnectionString) except excp = true endtry; 
	
endprocedure // OpenConnection();

procedure CloseConnection(Connection, excp = false) 
	
	try Connection.Close() except excp = true endtry;
	
	Connection = undefined;
	
endprocedure // CloseConnection()

procedure OpenRecordset(Recordset, Connection = undefined, val textExec, excp = false) 
	
	if Connection = undefined then OpenConnection(Connection, , excp) endif;
	
	try Recordset = new COMОбъект("ADODB.Recordset"); Recordset.Open(textExec, Connection) except excp = true endtry; 
	
endprocedure // OpenRecordset();

procedure OpenEditRecordset(Recordset, Connection = undefined, val table, val textFilter, excp = false) 
	
	if Connection = undefined then OpenConnection(Connection, , excp) endif;
	
	try Recordset = new COMОбъект("ADODB.Recordset"); Recordset.Filter = textFilter; Recordset.Open(table, Connection, 0, 4, 2) except excp = true endtry; 
	
endprocedure // OpenEditRecordset();

procedure RecordsetAddNew(Recordset, val record) 
	
	Recordset.AddNew(); for each col in record do Recordset.Fields(col.key).Value = col.value enddo;
	
endprocedure // RecordsetAddNew()

procedure CloseRecordset(Recordset, excp = false) 
	
	try Recordset.Close() except excp = true endtry;
	
	Recordset = undefined;
	
endprocedure // CloseRecordset()

procedure OpenLoadFromFileStream(Stream, val FullFileName, excp = false) 
	
	try Stream = new COMОбъект("ADODB.Stream");	Stream.Type = 1; Stream.Open(); Stream.LoadFromFile(FullFileName) except excp = true endtry;
	
endprocedure // OpenLoadFromFileStream()

procedure OpenSaveToFileStream(Stream, val FullFileName, val data, excp = false) 
	
	try Stream = new COMОбъект("ADODB.Stream"); Stream.Type = 1; Stream.Open(); Stream.Write(data); Stream.SaveToFile(FullFileName) except excp = true endtry;
	
endprocedure // OpenSaveToFileStream()

function ReadStream(Stream, val FullFileName, excp = false) 
	
	try OpenLoadFromFileStream(Stream, FullFileName, excp) except excp = true endtry;
	
	if excp = true then return null else return Stream.Read() endif;
	
endfunction // ReadStream()

procedure WriteStream(Stream, val FullFileName, val data, excp = false) 
	
	try OpenSaveToFileStream(Stream, FullFileName, data, excp) except excp = true endtry;
	
endprocedure // WriteStream()

function FileExist(val fullfilename)
	
	file = new File(fullfilename); return file.Exist();
	
endfunction // FileExist()

function FileIsDir(val fullfilename)
	
	file = new File(fullfilename); 
	
	if file.Exist() then return file.IsDirectory() else return false endif;
	
endfunction // FileIsDir()

function exec_text(val text, val preprocessing_text = "", val afterwork_text = "", excp = false)
	
	var Connection, Recordset, result;
	
	OpenConnection(Connection, , excp);
	
	if Connection = undefined then excp = true; return result endif;
	
	Connection.BeginTrans();
	
	////OpenRecordset(Recordset, Connection, text, excp);
	
	preprocessing(preprocessing_text, result, excp);
	
	try Recordset = Connection.Execute(text) except excp = true endtry;
	
	afterwork(afterwork_text, Recordset, result, excp);
	
	////CloseRecordset(Recordset, excp);
	
	if excp = true then Connection.RollbackTrans() else Connection.CommitTrans() endif;
	
	CloseConnection(Connection, excp);
	
	return result;
	
endfunction // exec_text()

procedure exec_put(val table, val id, val data, val filename, excp = false, version = undefined)
	
	var Connection, Recordset;
	
	OpenConnection(Connection, , excp);
	
	if Connection = undefined then excp = true; return endif;
	
	Connection.BeginTrans();
	
	if not version = undefined then
	
		vrs = version; version = null;
	
		Recordset = Connection.Execute("SELECT CAST(N'' AS XML).value('xs:base64Binary(xs:hexBinary(sql:column(""Version"")))', 'VARCHAR(MAX)') AS Version
			| FROM (SELECT Version FROM "+table+" WITH (HOLDLOCK) WHERE IDRRef = 0x"+id+") AS TT");
		
		while not Recordset.EOF do
			
			version = Base64Value(Recordset.Fields("Version").Value);
			
			Recordset.MoveNext();
			
		enddo;
		
		if not version = vrs then excp = true endif;
		
	endif;
	
	if not excp = true then
		
		try
		Connection.Execute("DELETE FROM "+table+" WITH (HOLDLOCK) WHERE IDRRef = 0x"+id);
		except
			excp = true; Message(ErrorDescription(), MessageStatus.VeryImportant);
			ЗаписьЖурналаРегистрации("Внешнее хранилище данных.Помещение данных", УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.ФайлыХранилищаДанных
				, Справочники.ФайлыХранилищаДанных.ПолучитьСсылку(Новый УникальныйИдентификатор(Справочники.ФайлыХранилищаДанных.УИН(id))), "DELETE"+Символы.ПС+ОписаниеОшибки());
		endtry;
		
		try
		Connection.Execute("INSERT INTO "+table+" (IDRRef, Marked, Description, Data)
			| VALUES (0x"+id+", 0x00, '"+filename+"', CAST(N'' AS XML).value('xs:base64Binary("""+Base64String(data)+""")', 'VARBINARY(MAX)'))");
		except
			excp = true; Message(ErrorDescription(), MessageStatus.VeryImportant); 
			ЗаписьЖурналаРегистрации("Внешнее хранилище данных.Помещение данных", УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.ФайлыХранилищаДанных
				, Справочники.ФайлыХранилищаДанных.ПолучитьСсылку(Новый УникальныйИдентификатор(Справочники.ФайлыХранилищаДанных.УИН(id))), "INSERT"+Символы.ПС+ОписаниеОшибки()
					+Символы.ПС+"INSERT INTO "+table+" (IDRRef, Marked, Description, Data)
				|VALUES (0x"+id+", 0x00, '"+filename+"', CAST(N'' AS XML).value('xs:base64Binary("""+Base64String(data)+""")', 'VARBINARY(MAX)'))");
		endtry;
	
	endif;
	
	if excp = true then Connection.RollbackTrans() else Connection.CommitTrans() endif;
	
	CloseConnection(Connection, excp);
	
endprocedure // exec_put()

procedure exec_get(val table, val id, data, filename, excp = false, version = undefined)
	
	var Connection, Recordset;
	
	OpenConnection(Connection, , excp);
	
	if Connection = undefined then excp = true; return endif;
	
	if excp = true then return endif;
	
	Connection.BeginTrans();
	
	Recordset = Connection.Execute("SELECT CAST(N'' AS XML).value('xs:base64Binary(xs:hexBinary(sql:column(""Data"")))', 'VARCHAR(MAX)') AS Data
		|, Description, CAST(N'' AS XML).value('xs:base64Binary(xs:hexBinary(sql:column(""Version"")))', 'VARCHAR(MAX)') AS Version
		| FROM (SELECT Data, Description, Version FROM "+table+" WITH (HOLDLOCK) WHERE IDRRef = 0x"+id+") AS TT");
	
	while not Recordset.EOF do
		
		data = Base64Value(Recordset.Fields("Data").Value);
		filename = Recordset.Fields("Description").Value;
		version = ?(version = undefined, version, Base64Value(Recordset.Fields("Version").Value));
	
		Recordset.MoveNext();
	
	enddo;
	
	if data = undefined then excp = true endif;
	
	CloseRecordset(Recordset, excp);
	
	Connection.RollbackTrans();
	
	CloseConnection(Connection, excp);
	
endprocedure // exec_get()

procedure storage_Schemes_AddNew(id, filename, fullfilename)
	
	//ExternalData = new ExternalDataSourceConnectionParameters;
	//ExternalData.ConnectionString = "DRIVER={SQL Server};SERVER=IT_258-PK";
	//ExternalData.DBMS = "MSSQLServer";
	//storage = ExternalDataSources.storage;
	//storage.SetCommonConnectionParameters(ExternalData);
	//storage.Connect();
	//
	//Object = storage.Таблицы.dbo_Schemes.CreateObject();
	//Object.IDRRef = Base64Value(id); 
	//Object.Value = new BinaryData(fullfilename); 
	//Object.Description = filename; 
	//Object.Write(); 
	
endprocedure // storage_Schemes_AddNew

procedure preprocessing(val text_preprocessing, result, excp)
	
	if IsBlankString(text_preprocessing) then return endif;
	
	try Execute(text_preprocessing) except excp = true endtry;
	
endprocedure // preprocessing()

procedure afterwork(val text_afterwork, val Recordset, result, excp)
	
	if IsBlankString(text_afterwork) then return endif;
	
	try Execute(text_afterwork) except excp = true endtry;
	
endprocedure // afterwork()

////////////////////////////////////////////////////////////////////////////////

#КонецОбласти

//Функция для переданного объекта возвращает его тип, для сохранения во внешней базе
Функция ИмяТаблицыХраненияДанныхВоВнешнемХранилище(ОбъектСвязанныеСДанными) Экспорт
	
	Если ТипЗнч(ОбъектСвязанныеСДанными) = Тип("СправочникСсылка.ВложенияЭлектронныхПисем") 
		Или ТипЗнч(ОбъектСвязанныеСДанными) = Тип("СправочникОбъект.ВложенияЭлектронныхПисем") Тогда
		
		// Attachments
		Возврат Метаданные.Перечисления.ТипыФайловХранилищаДанных.ЗначенияПеречисления.Attachments.Имя;
		
	ИначеЕсли ТипЗнч(ОбъектСвязанныеСДанными) = Тип("ПеречислениеСсылка.ТипыФайловХранилищаДанных") Тогда
		
		ИндексЗначенияПеречисления = Перечисления.ТипыФайловХранилищаДанных.Индекс(ОбъектСвязанныеСДанными);
		Возврат Метаданные.Перечисления.ТипыФайловХранилищаДанных.ЗначенияПеречисления[ИндексЗначенияПеречисления].Имя;
		
	ИначеЕсли Метаданные.ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(ОбъектСвязанныеСДанными))) Тогда
		
		Возврат Метаданные.НайтиПоТипу(ТипЗнч(ОбъектСвязанныеСДанными)).ИмяВИсточникеДанных;
		
	КонецЕсли;
	
	//Проверяем, если в метаданных переданного типа есть реквизит "тип" со значением Перечисление.ТипыФайловХранилищаДанных, то возвращаем его
	Реквизит = ОбъектСвязанныеСДанными.Метаданные().Реквизиты.Найти("Тип");
	Если Реквизит = Неопределено Тогда
		ВызватьИсключение "В функцию ""table_name"" передана ссылка на неизвестный объект "
			+ ОбъектСвязанныеСДанными + " (" + ТипЗнч(ОбъектСвязанныеСДанными) + ")";
	ИначеЕсли Не Реквизит.Тип.СодержитТип(Тип("ПеречислениеСсылка.ТипыФайловХранилищаДанных")) Тогда 
		ВызватьИсключение "В функцию ""table_name"" передана ссылка на объект "
			+ ОбъектСвязанныеСДанными + " ("+ТипЗнч(ОбъектСвязанныеСДанными)+"), который содержит реквизит ""Тип"" не соответсвующий перечислению ""ТипыФайловХранилищаДанных""";
	ИначеЕсли ОбъектСвязанныеСДанными.Тип.Пустая() Тогда 
		ВызватьИсключение "В функцию ""table_name"" передана ссылка на объект "+ОбъектСвязанныеСДанными+" ("+ТипЗнч(ОбъектСвязанныеСДанными)+"), с незаполненым реквизитом ""Тип""";
	КонецЕсли;
	
	ИндексЗначенияПеречисления = Перечисления.ТипыФайловХранилищаДанных.Индекс(ОбъектСвязанныеСДанными.Тип);
	Возврат Метаданные.Перечисления.ТипыФайловХранилищаДанных.ЗначенияПеречисления[ИндексЗначенияПеречисления].Имя;
	
КонецФункции

Функция ПоместитьДанныеВТаблицу(ИмяТаблицыХранения, СтруктураДанных, Отказ) Экспорт
	
	Перем ДанныеДляЗаписи, ПредставлениеДанных;
	
	Если Не МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочееХранилищеДанных Тогда
		
		Отказ = Истина;
		Возврат Неопределено; 

	КонецЕсли;

	Если Не ВнешнееХранилищеФайловПодключено() Тогда
		
		Отказ = Истина;
		Возврат Неопределено;
		
	КонецЕсли; 

	Если ТипЗнч(СтруктураДанных) = Тип("Структура") Тогда
		
		СтруктураДанных.Свойство("ДвоичныеДанные", ДанныеДляЗаписи);
		СтруктураДанных.Свойство("ПредставлениеДанных", ПредставлениеДанных);
		
	Иначе
		ОбщегоНазначения.СообщитьОбОшибке("Переданные данные не соответсвуют типу", Отказ, "Запись данных во внешнем хранилище");
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаписьТаблицы = ВнешниеИсточникиДанных.ФайловоеХранилище.Таблицы[ИмяТаблицыХранения].СоздатьОбъект();
	
	ЗаписьТаблицы.Data = Base64Строка(ДанныеДляЗаписи);
	ЗаписьТаблицы.Description = ПредставлениеДанных;
	
	ЗаписьТаблицы.Записать();
	
	Возврат ЗаписьТаблицы.Ссылка;
	
КонецФункции

Функция ОбновитьДанныеЗаписиТаблицы(СсылкаНаЗаписиВТаблице, СтруктураДанных, Отказ) Экспорт
	
	Перем ДанныеДляЗаписи, ПредставлениеДанных;
	
	Если Не МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочееХранилищеДанных Тогда
		
		Отказ = Истина;
		Возврат Неопределено; 

	КонецЕсли;

	Если Не ВнешнееХранилищеФайловПодключено() Тогда
		
		Отказ = Истина;
		Возврат Неопределено;
		
	КонецЕсли; 

	Если ТипЗнч(СтруктураДанных) = Тип("Структура") Тогда
		
		СтруктураДанных.Свойство("ДвоичныеДанные", ДанныеДляЗаписи);
		СтруктураДанных.Свойство("ПредставлениеДанных", ПредставлениеДанных);
		
	Иначе
		
		ОбщегоНазначения.СообщитьОбОшибке("Переданные данные не соответсвуют типу", Отказ, "Запись данных во внешнем хранилище");
		Возврат Неопределено;

	КонецЕсли;
	
	СтрокаДанных = Base64Строка(ДанныеДляЗаписи);
	Если СсылкаНаЗаписиВТаблице.Data = СтрокаДанных 
		И СсылкаНаЗаписиВТаблице.Description = ПредставлениеДанных Тогда
		
			//Ничего не меняем
			Возврат СсылкаНаЗаписиВТаблице;
			
	КонецЕсли; 
	
	ЗаписьТаблицы = СсылкаНаЗаписиВТаблице.ПолучитьОбъект();
	ЗаписьТаблицы.Data = Base64Строка(ДанныеДляЗаписи);
	ЗаписьТаблицы.Description = ПредставлениеДанных;
	
	ЗаписьТаблицы.Записать();
	
	Возврат ЗаписьТаблицы.Ссылка;
	
КонецФункции

Процедура ИзменитьЗначениеПоляЗаписиТаблицы(СсылкаНаЗаписиВТаблице, ИмяПоля, НовоеЗначениеПоля, Отказ) Экспорт
	
	Если Не МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочееХранилищеДанных Тогда
		
		Отказ = Истина;
		Возврат; 

	КонецЕсли;

	Если Не ВнешнееХранилищеФайловПодключено() Тогда
		
		Отказ = Истина;
		Возврат;
		
	КонецЕсли;
	
	ЗаписьТаблицы = СсылкаНаЗаписиВТаблице.ПолучитьОбъект();
	Если ЗаписьТаблицы = Неопределено Тогда
		
		ОбщегоНазначения.СообщитьОбОшибке("Неудалось прочитать запись из внешнего хранилища.", Отказ, "Внешнее хранилище данных");
		Отказ = Истина;
		
		Возврат;
		
	КонецЕсли; 
	
	ЗаписьТаблицы[ИмяПоля] = НовоеЗначениеПоля;
	
	Попытка
		
		ЗаписьТаблицы.Записать();
		
	Исключение
		
		ОбщегоНазначения.СообщитьОбОшибке("Ошибка при установки нового значения поля " + ИмяПоля + " записи внешнего хранилища."
			, Отказ, "Внешнее хранилище данных");
		
	КонецПопытки;
	
КонецПроцедуры

Функция ПолучитьДанныеИзТаблицы(СсылкаНаЗаписиВТаблице, Отказ) Экспорт
	
	Если Не МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочееХранилищеДанных Тогда
		
		Отказ = Истина;
		Возврат Неопределено; 

	КонецЕсли;

	Если Не ВнешнееХранилищеФайловПодключено() Тогда
		
		Отказ = Истина;
		Возврат Неопределено;
		
	КонецЕсли;
	
	СтруктураДанных = Новый Структура();
	
	СтруктураДанных.Вставить("ДвоичныеДанные", Base64Значение(СсылкаНаЗаписиВТаблице.Data));
	СтруктураДанных.Вставить("ПредставлениеДанных", СсылкаНаЗаписиВТаблице.Description);
	СтруктураДанных.Вставить("Версия", СсылкаНаЗаписиВТаблице.Version);
	
	Возврат СтруктураДанных;
	
КонецФункции

Функция ПолучитьВерсиюЗаписиТаблицы(СсылкаНаЗаписиВТаблице, Отказ) Экспорт
	
	Если Не МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочееХранилищеДанных Тогда
		
		Отказ = Истина;
		Возврат Неопределено; 

	КонецЕсли;

	Если Не ВнешнееХранилищеФайловПодключено() Тогда
		
		Отказ = Истина;
		Возврат Неопределено;
		
	КонецЕсли;

	Возврат СсылкаНаЗаписиВТаблице.Version;

КонецФункции

Процедура УдалитьЗаписьИзТаблицы(СсылкаНаЗаписиВТаблице, Отказ) Экспорт
	
	Если Не МодульРаботыСФайламиХранилищаДанныхПовтИсп.ЭтоРабочееХранилищеДанных Тогда
		
		Отказ = Истина;
		Возврат Неопределено; 

	КонецЕсли;

	Если Не ВнешнееХранилищеФайловПодключено() Тогда
		
		Отказ = Истина;
		Возврат;
		
	КонецЕсли;
	
	ЗаписьТаблицы = СсылкаНаЗаписиВТаблице.ПолучитьОбъект();
	Если ЗаписьТаблицы = Неопределено Тогда
		
		ОбщегоНазначения.СообщитьОбОшибке("Неудалось прочитать запись из внешнего хранилища.", Отказ, "Внешнее хранилище данных");
		Отказ = Истина;
		
		Возврат;
		
	КонецЕсли; 
	
	ЗаписьТаблицы[ИмяПоля] = НовоеЗначениеПоля;
	
	Попытка
		
		ЗаписьТаблицы.Удалить();
		
	Исключение
		
		ОбщегоНазначения.СообщитьОбОшибке("Ошибка при удалении записи из внешнего хранилища" , Отказ, "Внешнее хранилище данных");
		
	КонецПопытки;
	
КонецПроцедуры

Функция ВнешнееХранилищеФайловПодключено() Экспорт
	
	Если ВнешниеИсточникиДанных.ФайловоеХранилище.ПолучитьСостояние() = СостояниеВнешнегоИсточникаДанных.Отключен Тогда
		
		ПодключитьВнешнееХранилищеФайлов();
		Возврат ВнешниеИсточникиДанных.ФайловоеХранилище.ПолучитьСостояние() = СостояниеВнешнегоИсточникаДанных.Подключен;
		
	КонецЕсли; 
	
	Возврат Истина;
	
КонецФункции

Процедура ПодключитьВнешнееХранилищеФайлов()
	
	ПараметрыСоединения = ПараметрыСоединенияСВнешнимХранилищем();
	ВнешниеИсточникиДанных.ФайловоеХранилище.УстановитьПараметрыСоединенияСеанса(ПараметрыСоединения);
	
	Попытка
		ВнешниеИсточникиДанных.ФайловоеХранилище.УстановитьСоединение();
	Исключение
		
		ТекстОшибки = "Ошибка подключения к внешней хранилищю файлов: 
			|" + ОписаниеОшибки();
		
		ОбщегоНазначения.СообщитьОбОшибке(ТекстОшибки,, "Внешнее хранилище данных");
		
	КонецПопытки;
	
КонецПроцедуры

Функция ПараметрыСоединенияСВнешнимХранилищем()
	
	ПараметрыСоединения = Константы.ПараметрыПодключенияКХранилищуФайлов.Получить().Получить();
	
	Если Не ТипЗнч(ПараметрыСоединения) = Тип("ПараметрыСоединенияВнешнегоИсточникаДанных") Тогда
		ОбщегоНазначения.СообщитьОбОшибке("Параметры подключения к внешнему хранилищу файлов не установлены!",, "Внешнее хранилище данных");
	КонецЕсли; 
	
	Возврат ПараметрыСоединения;
	
	// Нужно получить параметры их данных сохраненных в базе
	ПараметрыСоединения = Новый ПараметрыСоединенияВнешнегоИсточникаДанных();
	
	ПараметрыСоединения.АутентификацияОС = Ложь;
	ПараметрыСоединения.ИмяПользователя = "sa";
	ПараметрыСоединения.Пароль = "admin31";
	
	//ПараметрыСоединения.СтрокаСоединения = "DRIVER={SQL Server Native Client 11.0};SERVER=Yudin;UID=sa;PWD=admin31;DATABASE=files_1c";
	//ПараметрыСоединения.СтрокаСоединения = "DRIVER={ODBC Driver 11 for SQL Server};SERVER=Yudin;DATABASE=files_1c";
	ПараметрыСоединения.СтрокаСоединения = "DRIVER={SQL Server};SERVER=Yudin;DATABASE=files_1c";
		
	ПараметрыСоединения.СУБД = "MSSQLServer";
	
	Возврат ПараметрыСоединения;
	
КонецФункции

// Проверяет связь элемента спр.ФайлыХранилищаДанных с данными внешнего хранилища.
//
// Параметры:
//  ФайлХранилищаДанных	 - СправочникиСсылка.ФайлыХранилищаДанных - Ссылка на элемент 
//		справочника который связан с данных внешнего хранилища
// 
// Возвращаемое значение:
//	Булево - Истина, если элемент справочника связан с данными внешнего хранилища иначе Ложь.
//
Функция ФайлСодержитДвоичныеДанные(ФайлХранилищаДанных)
	
	ИмяТаблицыХранилища = ИмяТаблицыХраненияДанныхВоВнешнемХранилище(ФайлХранилищаДанных);
	Если Не ВнешнееХранилищеФайловПодключено() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Не ФайлХранилищаДанных["Ссылка" + ИмяТаблицыХранилища].Пустая();
	
КонецФункции

